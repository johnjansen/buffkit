package auth

import (
	"context"
	"crypto/rand"
	"database/sql"
	"errors"
	"fmt"
	"net/http"
	"strings"
	"sync"
	"time"

	"github.com/gobuffalo/buffalo"
	"github.com/gobuffalo/buffalo/render"
	"golang.org/x/crypto/bcrypt"
)

// Common errors returned by auth operations.
// These are sentinel errors that can be checked with errors.Is()
var (
	// ErrInvalidCredentials is returned when login fails due to bad email/password
	ErrInvalidCredentials = errors.New("invalid email or password")

	// ErrUserNotFound is returned when a user lookup fails
	ErrUserNotFound = errors.New("user not found")

	// ErrUserExists is returned when trying to create a user with duplicate email
	ErrUserExists = errors.New("user already exists")

	// ErrAccountLocked is returned when a locked account tries to login
	ErrAccountLocked = errors.New("account is locked")

	// ErrTokenExpired is returned when a verification/reset token has expired
	ErrTokenExpired = errors.New("token has expired")

	// ErrTokenInvalid is returned when a token is malformed or doesn't exist
	ErrTokenInvalid = errors.New("invalid token")
)

// UserStore is the interface that must be implemented for user persistence.
// This allows applications to use any database or storage system.
type UserStore interface {
	// Create adds a new user to the store.
	// The user's ID should be generated by this method.
	// Returns ErrUserExists if email already exists.
	Create(ctx context.Context, u *User) error

	// ByEmail retrieves a user by email address.
	// Returns ErrUserNotFound if user doesn't exist.
	// Used during login to find user for authentication.
	ByEmail(ctx context.Context, email string) (*User, error)

	// ByID retrieves a user by ID.
	// Returns ErrUserNotFound if user doesn't exist.
	// Used to get current user from session-stored ID.
	ByID(ctx context.Context, id string) (*User, error)

	// UpdatePassword updates a user's password digest.
	// Used for password reset flows.
	// Returns ErrUserNotFound if user doesn't exist.
	UpdatePassword(ctx context.Context, id, digest string) error

	// ExistsEmail checks if an email is already registered.
	// Used during registration to validate uniqueness.
	// Should be fast as it's called on every registration attempt.
	ExistsEmail(ctx context.Context, email string) (bool, error)
}

// Global store instance - set by the application via UseStore()
var (
	store UserStore
	mu    sync.RWMutex
)

// UseStore sets the global user store implementation.
// This should be called once during application initialization.
// Example:
//
//	auth.UseStore(auth.NewSQLStore(db, "postgres"))
func UseStore(s UserStore) {
	mu.Lock()
	defer mu.Unlock()
	store = s
}

// GetStore returns the current user store.
// Returns nil if no store has been configured.
// Most auth operations will fail if store is nil.
func GetStore() UserStore {
	mu.RLock()
	defer mu.RUnlock()
	return store
}

// SQLStore implements UserStore with SQL database.
// Supports PostgreSQL, MySQL, and SQLite dialects.
type SQLStore struct {
	db      *sql.DB
	dialect string // "postgres", "mysql", or "sqlite"
}

// NewSQLStore creates a new SQL-backed user store.
// Dialect should be one of: "postgres", "mysql", "sqlite".
// Returns nil if db is nil.
//
// Example:
//
//	store := auth.NewSQLStore(db, "postgres")
//	auth.UseStore(store)
func NewSQLStore(db *sql.DB, dialect string) *SQLStore {
	if db == nil {
		return nil
	}
	return &SQLStore{
		db:      db,
		dialect: strings.ToLower(dialect),
	}
}

// Create adds a new user to the database.
// Generates a UUID for the user ID.
// Returns ErrUserExists if email is already taken.
func (s *SQLStore) Create(ctx context.Context, u *User) error {
	// Check if email exists
	exists, err := s.ExistsEmail(ctx, u.Email)
	if err != nil {
		return fmt.Errorf("failed to check email existence: %w", err)
	}
	if exists {
		return ErrUserExists
	}

	// Generate ID if not set
	if u.ID == "" {
		u.ID = generateUUID()
	}

	// Set timestamps
	now := time.Now()
	u.CreatedAt = now
	u.UpdatedAt = now

	// Insert user
	query := `
		INSERT INTO users (
			id, email, password_digest,
			first_name, last_name, display_name,
			is_active, is_verified,
			email_verification_token, email_verification_sent_at,
			created_at, updated_at
		) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
	`

	_, err = s.db.ExecContext(ctx, query,
		u.ID, u.Email, u.PasswordDigest,
		u.FirstName, u.LastName, u.DisplayName,
		u.IsActive, u.IsVerified,
		u.EmailVerificationToken, u.EmailVerificationSentAt,
		u.CreatedAt, u.UpdatedAt,
	)

	if err != nil {
		return fmt.Errorf("failed to create user: %w", err)
	}

	return nil
}

// ByEmail retrieves a user by email address
func (s *SQLStore) ByEmail(ctx context.Context, email string) (*User, error) {
	u := &User{}
	query := `
		SELECT id, email, password_digest,
		       first_name, last_name, display_name,
		       is_active, is_verified, is_admin,
		       failed_login_attempts, locked_until,
		       created_at, updated_at
		FROM users WHERE email = $1
	`

	err := s.db.QueryRowContext(ctx, query, email).Scan(
		&u.ID, &u.Email, &u.PasswordDigest,
		&u.FirstName, &u.LastName, &u.DisplayName,
		&u.IsActive, &u.IsVerified, &u.IsAdmin,
		&u.FailedLoginAttempts, &u.LockedUntil,
		&u.CreatedAt, &u.UpdatedAt,
	)

	if err == sql.ErrNoRows {
		return nil, ErrUserNotFound
	}
	if err != nil {
		return nil, fmt.Errorf("failed to get user by email: %w", err)
	}

	return u, nil
}

// ByID retrieves a user by ID
func (s *SQLStore) ByID(ctx context.Context, id string) (*User, error) {
	u := &User{}
	query := `
		SELECT id, email, password_digest,
		       first_name, last_name, display_name,
		       is_active, is_verified, is_admin,
		       created_at, updated_at
		FROM users WHERE id = $1
	`

	err := s.db.QueryRowContext(ctx, query, id).Scan(
		&u.ID, &u.Email, &u.PasswordDigest,
		&u.FirstName, &u.LastName, &u.DisplayName,
		&u.IsActive, &u.IsVerified, &u.IsAdmin,
		&u.CreatedAt, &u.UpdatedAt,
	)

	if err == sql.ErrNoRows {
		return nil, ErrUserNotFound
	}
	if err != nil {
		return nil, fmt.Errorf("failed to get user by id: %w", err)
	}

	return u, nil
}

// UpdatePassword updates a user's password
func (s *SQLStore) UpdatePassword(ctx context.Context, id, digest string) error {
	query := `
		UPDATE users
		SET password_digest = $2, updated_at = $3
		WHERE id = $1
	`

	result, err := s.db.ExecContext(ctx, query, id, digest, time.Now())
	if err != nil {
		return fmt.Errorf("failed to update password: %w", err)
	}

	rows, err := result.RowsAffected()
	if err != nil {
		return err
	}
	if rows == 0 {
		return ErrUserNotFound
	}

	return nil
}

// ExistsEmail checks if an email is already registered
func (s *SQLStore) ExistsEmail(ctx context.Context, email string) (bool, error) {
	var count int
	query := `SELECT COUNT(*) FROM users WHERE email = $1`
	err := s.db.QueryRowContext(ctx, query, email).Scan(&count)
	if err != nil {
		return false, fmt.Errorf("failed to check email existence: %w", err)
	}
	return count > 0, nil
}

// MemoryStore implements UserStore with in-memory storage.
// Useful for testing and development without a database.
type MemoryStore struct {
	mu      sync.RWMutex
	users   map[string]*User  // id -> user
	byEmail map[string]string // email -> id
}

// NewMemoryStore creates a new in-memory user store
func NewMemoryStore() *MemoryStore {
	return &MemoryStore{
		users:   make(map[string]*User),
		byEmail: make(map[string]string),
	}
}

// Create adds a user to memory
func (m *MemoryStore) Create(ctx context.Context, u *User) error {
	m.mu.Lock()
	defer m.mu.Unlock()

	if _, exists := m.byEmail[u.Email]; exists {
		return ErrUserExists
	}

	if u.ID == "" {
		u.ID = generateUUID()
	}

	now := time.Now()
	u.CreatedAt = now
	u.UpdatedAt = now

	m.users[u.ID] = u
	m.byEmail[u.Email] = u.ID
	return nil
}

// ByEmail retrieves a user by email
func (m *MemoryStore) ByEmail(ctx context.Context, email string) (*User, error) {
	m.mu.RLock()
	defer m.mu.RUnlock()

	id, exists := m.byEmail[email]
	if !exists {
		return nil, ErrUserNotFound
	}
	return m.users[id], nil
}

// ByID retrieves a user by ID
func (m *MemoryStore) ByID(ctx context.Context, id string) (*User, error) {
	m.mu.RLock()
	defer m.mu.RUnlock()

	user, exists := m.users[id]
	if !exists {
		return nil, ErrUserNotFound
	}
	return user, nil
}

// UpdatePassword updates a user's password
func (m *MemoryStore) UpdatePassword(ctx context.Context, id, digest string) error {
	m.mu.Lock()
	defer m.mu.Unlock()

	user, exists := m.users[id]
	if !exists {
		return ErrUserNotFound
	}
	user.PasswordDigest = digest
	user.UpdatedAt = time.Now()
	return nil
}

// ExistsEmail checks if an email exists
func (m *MemoryStore) ExistsEmail(ctx context.Context, email string) (bool, error) {
	m.mu.RLock()
	defer m.mu.RUnlock()
	_, exists := m.byEmail[email]
	return exists, nil
}

// Password hashing utilities

// HashPassword creates a bcrypt hash of the password.
// Uses bcrypt's default cost (10).
// Returns the base64-encoded hash suitable for storage.
func HashPassword(password string) (string, error) {
	bytes, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	return string(bytes), err
}

// CheckPassword compares a password with its hash.
// Returns nil if they match, error otherwise.
// Timing-safe to prevent timing attacks.
func CheckPassword(password, hash string) error {
	return bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
}

// generateUUID creates a new random UUID
func generateUUID() string {
	b := make([]byte, 16)
	rand.Read(b)
	return fmt.Sprintf("%x-%x-%x-%x-%x",
		b[0:4], b[4:6], b[6:8], b[8:10], b[10:])
}

// Session management

// sessionKey is the key used to store user ID in session
const sessionKey = "current_user_id"

// SetUserSession stores the user ID in the session.
// Called after successful login to establish the session.
// The actual session cookie is handled by Buffalo.
func SetUserSession(c buffalo.Context, userID string) error {
	c.Session().Set(sessionKey, userID)
	return c.Session().Save()
}

// GetUserSession retrieves the user ID from session.
// Returns empty string if no user is logged in.
// This is a low-level function - use CurrentUser() for the full user object.
func GetUserSession(c buffalo.Context) string {
	if uid := c.Session().Get(sessionKey); uid != nil {
		if id, ok := uid.(string); ok {
			return id
		}
	}
	return ""
}

// ClearUserSession removes the user from session.
// Called during logout to end the session.
// The session cookie itself may persist but will be empty.
func ClearUserSession(c buffalo.Context) error {
	c.Session().Delete(sessionKey)
	c.Session().Clear()
	return c.Session().Save()
}

// CurrentUser retrieves the currently logged-in user.
// Returns nil if no user is logged in or if user lookup fails.
// This is commonly used in templates and handlers to get user info.
//
// Example in handler:
//
//	user := auth.CurrentUser(c)
//	if user == nil {
//	    return c.Redirect(302, "/login")
//	}
//
// Example in template:
//
//	<% if (current_user) { %>
//	    Welcome, <%= current_user.Email %>!
//	<% } %>
func CurrentUser(c buffalo.Context) *User {
	// Check if already cached in context
	if u := c.Value("current_user"); u != nil {
		if user, ok := u.(*User); ok {
			return user
		}
	}

	// Get user ID from session
	userID := GetUserSession(c)
	if userID == "" {
		return nil
	}

	// Look up user
	store := GetStore()
	if store == nil {
		return nil
	}

	user, err := store.ByID(c.Request().Context(), userID)
	if err != nil {
		// User doesn't exist anymore, clear session
		ClearUserSession(c)
		return nil
	}

	// Cache in context for this request
	c.Set("current_user", user)
	return user
}

// RequireLogin is middleware that ensures user is authenticated.
// If not logged in, redirects to /login.
// If logged in, adds user to context and continues.
//
// Usage:
//
//	app.GET("/admin", auth.RequireLogin(AdminHandler))
//	// or for groups:
//	protected := app.Group("/admin")
//	protected.Use(auth.RequireLogin)
func RequireLogin(next buffalo.Handler) buffalo.Handler {
	return func(c buffalo.Context) error {
		user := CurrentUser(c)
		if user == nil {
			// For AJAX requests, return 401
			if c.Request().Header.Get("X-Requested-With") == "XMLHttpRequest" {
				return c.Error(http.StatusUnauthorized, errors.New("authentication required"))
			}
			// For regular requests, redirect to login
			return c.Redirect(http.StatusSeeOther, "/login")
		}

		// User is logged in, continue
		c.Set("current_user", user)
		return next(c)
	}
}

// LoginFormHandler renders the login page.
// Shows any flash messages from previous attempts.
// Redirects to dashboard if already logged in.
func LoginFormHandler(c buffalo.Context) error {
	// If already logged in, redirect to home
	if CurrentUser(c) != nil {
		return c.Redirect(http.StatusSeeOther, "/")
	}

	// Prepare form data
	c.Set("form", struct{ Email string }{})

	// For now, return simple HTML until template system is properly integrated
	html := `<html><body><h1>Login</h1><form method="POST" action="/login">
		<input type="email" name="email" placeholder="Email" required>
		<input type="password" name="password" placeholder="Password" required>
		<button type="submit">Login</button>
		</form></body></html>`

	return c.Render(http.StatusOK, r.String(html))
}

// LoginHandler processes login form submission.
// Validates credentials, creates session on success.
// Shows errors on failure without revealing whether email exists.
func LoginHandler(c buffalo.Context) error {
	email := c.Param("email")
	password := c.Param("password")

	// Get store
	store := GetStore()
	if store == nil {
		c.Flash().Add("error", "Authentication system not configured")
		return c.Redirect(http.StatusSeeOther, "/login")
	}

	// Find user
	user, err := store.ByEmail(c.Request().Context(), strings.ToLower(strings.TrimSpace(email)))
	if err != nil {
		// Don't reveal whether email exists
		c.Flash().Add("error", "Invalid email or password")
		c.Set("form", struct{ Email string }{Email: email})

		// Return error with simple HTML
		html := `<html><body><h1>Login</h1><p style="color:red">Invalid email or password</p>
			<form method="POST" action="/login">
			<input type="email" name="email" placeholder="Email" value="` + email + `" required>
			<input type="password" name="password" placeholder="Password" required>
			<button type="submit">Login</button>
			</form></body></html>`
		return c.Render(http.StatusUnprocessableEntity, r.String(html))
	}

	// Check if account is locked
	if user.IsLocked() {
		c.Flash().Add("error", "Account is locked. Please contact support.")
		return c.Redirect(http.StatusSeeOther, "/login")
	}

	// Verify password
	if err := CheckPassword(password, user.PasswordDigest); err != nil {
		// Record failed attempt if using extended store
		if extStore, ok := store.(ExtendedUserStore); ok {
			extStore.IncrementFailedLoginAttempts(c.Request().Context(), email)
		}

		c.Flash().Add("error", "Invalid email or password")
		c.Set("form", struct{ Email string }{Email: email})

		// Return error with simple HTML
		html := `<html><body><h1>Login</h1><p style="color:red">Invalid email or password</p>
			<form method="POST" action="/login">
			<input type="email" name="email" placeholder="Email" value="` + email + `" required>
			<input type="password" name="password" placeholder="Password" required>
			<button type="submit">Login</button>
			</form></body></html>`
		return c.Render(http.StatusUnprocessableEntity, r.String(html))
	}

	// Check if account is active
	if !user.IsActive {
		c.Flash().Add("error", "Account is not active")
		return c.Redirect(http.StatusSeeOther, "/login")
	}

	// Reset failed attempts on successful login
	if extStore, ok := store.(ExtendedUserStore); ok {
		extStore.ResetFailedLoginAttempts(c.Request().Context(), email)

		// Log successful login
		audit := &AuditLog{
			ID:          generateUUID(),
			UserID:      &user.ID,
			EventType:   string(EventLogin),
			EventStatus: string(StatusSuccess),
			IPAddress:   getClientIP(c.Request()),
			UserAgent:   c.Request().UserAgent(),
			CreatedAt:   time.Now(),
		}
		extStore.LogAuthEvent(c.Request().Context(), audit)
	}

	// Create session
	if err := SetUserSession(c, user.ID); err != nil {
		c.Flash().Add("error", "Failed to create session")
		return c.Redirect(http.StatusSeeOther, "/login")
	}

	// Redirect to original URL or dashboard
	redirectTo := c.Session().Get("redirect_to")
	c.Session().Delete("redirect_to")
	if redirectTo != nil {
		if url, ok := redirectTo.(string); ok && url != "" {
			return c.Redirect(http.StatusSeeOther, url)
		}
	}

	c.Flash().Add("success", "Welcome back!")
	return c.Redirect(http.StatusSeeOther, "/")
}

// LogoutHandler destroys the user session.
// Clears all session data and redirects to home.
// Can be called via POST for security (CSRF protection).
func LogoutHandler(c buffalo.Context) error {
	user := CurrentUser(c)

	// Log logout event if user was logged in
	if user != nil {
		store := GetStore()
		if extStore, ok := store.(ExtendedUserStore); ok {
			audit := &AuditLog{
				ID:          generateUUID(),
				UserID:      &user.ID,
				EventType:   string(EventLogout),
				EventStatus: string(StatusSuccess),
				IPAddress:   getClientIP(c.Request()),
				UserAgent:   c.Request().UserAgent(),
				CreatedAt:   time.Now(),
			}
			extStore.LogAuthEvent(c.Request().Context(), audit)
		}
	}

	// Clear session
	if err := ClearUserSession(c); err != nil {
		c.Logger().Error("Failed to clear session:", err)
	}

	c.Flash().Add("success", "You have been logged out")
	return c.Redirect(http.StatusSeeOther, "/")
}

// Helper to get client IP
func getClientIP(r *http.Request) string {
	forwarded := r.Header.Get("X-Forwarded-For")
	if forwarded != "" {
		parts := strings.Split(forwarded, ",")
		return strings.TrimSpace(parts[0])
	}

	if realIP := r.Header.Get("X-Real-IP"); realIP != "" {
		return realIP
	}

	parts := strings.Split(r.RemoteAddr, ":")
	if len(parts) > 0 {
		return parts[0]
	}
	return r.RemoteAddr
}

// Package-level renderer for non-HTML responses
var r = render.New(render.Options{})
