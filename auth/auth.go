// Package auth provides session-based authentication for Buffalo applications.
// It implements a simple but secure authentication system similar to Rails' Devise
// but without the complexity. The package provides:
//   - User model with email/password authentication
//   - Session-based login (cookie storage)
//   - Password hashing with bcrypt
//   - Pluggable user storage (SQL by default, memory for testing)
//   - Login/logout handlers and middleware
//
// The auth flow works as follows:
//  1. User submits email/password to POST /login
//  2. System verifies credentials against user store
//  3. On success, user ID is stored in encrypted session cookie
//  4. RequireLogin middleware checks session on protected routes
//  5. POST /logout clears the session
//
// Security features:
//   - Passwords are never stored, only bcrypt hashes
//   - Sessions are encrypted with the configured AuthSecret
//   - CSRF protection on POST endpoints (via Buffalo)
//   - Timing-safe password comparison
package auth

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"io"
	"net/http"
	"time"

	"github.com/gobuffalo/buffalo"
	"github.com/gobuffalo/buffalo/render"
	"golang.org/x/crypto/bcrypt"
)

var (
	// ErrInvalidCredentials is returned when login fails due to wrong email/password.
	// We intentionally use the same error for "user not found" and "wrong password"
	// to prevent user enumeration attacks.
	ErrInvalidCredentials = errors.New("invalid email or password")

	// ErrUserNotFound is returned when querying for a non-existent user by ID.
	// This is only used internally - login always returns ErrInvalidCredentials.
	ErrUserNotFound = errors.New("user not found")

	// ErrUserExists is returned when trying to create a user with duplicate email.
	// Email addresses must be unique as they're used for login.
	ErrUserExists = errors.New("user already exists")
)

// User represents an authenticated user in the system.
// This is the core model for authentication. The struct tags indicate
// database column names and JSON serialization behavior.
//
// Note that PasswordDigest has json:"-" to prevent it from ever being
// accidentally serialized to JSON (API responses, logs, etc).
type User struct {
	// ID uniquely identifies the user (typically UUID or auto-increment)
	ID string `db:"id" json:"id"`

	// Email is the user's email address and login identifier.
	// Must be unique across all users.
	Email string `db:"email" json:"email"`

	// PasswordDigest is the bcrypt hash of the user's password.
	// Never store actual passwords! This field is excluded from JSON.
	PasswordDigest string `db:"password_digest" json:"-"`

	// CreatedAt timestamp when user was created
	CreatedAt time.Time `db:"created_at" json:"created_at"`

	// UpdatedAt timestamp of last user modification
	UpdatedAt time.Time `db:"updated_at" json:"updated_at"`
}

// UserStore defines the interface for user persistence.
// This abstraction allows different storage backends (SQL, memory, Redis, etc)
// without changing the auth logic. Implement this interface to use custom storage.
//
// WHY an interface: Allows testing with mock stores, switching databases,
// or even using external auth services while keeping the same API.
type UserStore interface {
	// Create adds a new user to the store.
	// The user's ID should be generated by this method.
	// Returns ErrUserExists if email already exists.
	Create(ctx context.Context, u *User) error

	// ByEmail retrieves a user by email address.
	// Returns ErrUserNotFound if user doesn't exist.
	// Used during login to find user for authentication.
	ByEmail(ctx context.Context, email string) (*User, error)

	// ByID retrieves a user by ID.
	// Returns ErrUserNotFound if user doesn't exist.
	// Used to get current user from session-stored ID.
	ByID(ctx context.Context, id string) (*User, error)

	// UpdatePassword updates a user's password digest.
	// Used for password reset flows (not yet implemented).
	// Returns ErrUserNotFound if user doesn't exist.
	UpdatePassword(ctx context.Context, id, digest string) error

	// ExistsEmail checks if an email is already registered.
	// Used during registration to validate uniqueness.
	// Should be fast as it's called on every registration attempt.
	ExistsEmail(ctx context.Context, email string) (bool, error)
}

// Global store instance (can be overridden).
// This allows the auth package to work without dependency injection
// while still being flexible for testing and custom stores.
var store UserStore

// UseStore sets the global user store.
// Call this during app initialization to use a custom store:
//
//	auth.UseStore(myCustomStore)
//
// If not called, GetStore() returns a default in-memory store.
func UseStore(s UserStore) {
	store = s
}

// GetStore returns the current user store.
// If no store has been set via UseStore, it returns a default
// in-memory store suitable for development and testing.
//
// This pattern (global with override) balances simplicity with flexibility.
func GetStore() UserStore {
	if store == nil {
		// Return a default in-memory store for development
		// This allows the auth system to work without any database setup
		return NewMemoryStore()
	}
	return store
}

// SQLStore is the default SQL-based user store.
// It works with any database that supports database/sql (Postgres, MySQL, SQLite).
// The dialect parameter allows for database-specific SQL where needed.
type SQLStore struct {
	db      *sql.DB // Database connection
	dialect string  // "postgres" | "mysql" | "sqlite"
}

// NewSQLStore creates a new SQL-based user store.
// Pass the database connection and dialect for SQL variations.
// Returns nil if db is nil (allows graceful degradation).
//
// Example:
//
//	db, _ := sql.Open("postgres", "...")
//	store := auth.NewSQLStore(db, "postgres")
//	auth.UseStore(store)
func NewSQLStore(db *sql.DB, dialect string) *SQLStore {
	if db == nil {
		// Return nil to indicate no database configured
		// This allows the app to start even without a database
		return nil
	}
	return &SQLStore{
		db:      db,
		dialect: dialect,
	}
}

// Create adds a new user to the database.
// This method:
//  1. Checks if email already exists (prevents duplicates)
//  2. Generates a unique ID for the user
//  3. Sets timestamps
//  4. Inserts into database
//
// The password should already be hashed before calling this method.
// Use HashPassword() to create the digest from a plain password.
func (s *SQLStore) Create(ctx context.Context, u *User) error {
	if s == nil || s.db == nil {
		return errors.New("database not configured")
	}

	// Check if user exists to enforce email uniqueness
	exists, err := s.ExistsEmail(ctx, u.Email)
	if err != nil {
		return err
	}
	if exists {
		return ErrUserExists
	}

	// Generate ID based on dialect
	// TODO: Use proper UUID library or database auto-increment
	switch s.dialect {
	case "postgres":
		u.ID = generateUUID()
	case "sqlite", "mysql":
		u.ID = generateUUID()
	}

	u.CreatedAt = time.Now()
	u.UpdatedAt = time.Now()

	// Insert user into database
	// Using parameterized query to prevent SQL injection
	query := `
		INSERT INTO users (id, email, password_digest, created_at, updated_at)
		VALUES ($1, $2, $3, $4, $5)
	`

	_, err = s.db.ExecContext(ctx, query, u.ID, u.Email, u.PasswordDigest, u.CreatedAt, u.UpdatedAt)
	return err
}

// ByEmail retrieves a user by email
func (s *SQLStore) ByEmail(ctx context.Context, email string) (*User, error) {
	if s == nil || s.db == nil {
		return nil, errors.New("database not configured")
	}

	var u User
	query := `
		SELECT id, email, password_digest, created_at, updated_at
		FROM users
		WHERE email = $1
	`

	err := s.db.QueryRowContext(ctx, query, email).Scan(
		&u.ID, &u.Email, &u.PasswordDigest, &u.CreatedAt, &u.UpdatedAt,
	)

	if err == sql.ErrNoRows {
		return nil, ErrUserNotFound
	}

	return &u, err
}

// ByID retrieves a user by ID
func (s *SQLStore) ByID(ctx context.Context, id string) (*User, error) {
	if s == nil || s.db == nil {
		return nil, errors.New("database not configured")
	}

	var u User
	query := `
		SELECT id, email, password_digest, created_at, updated_at
		FROM users
		WHERE id = $1
	`

	err := s.db.QueryRowContext(ctx, query, id).Scan(
		&u.ID, &u.Email, &u.PasswordDigest, &u.CreatedAt, &u.UpdatedAt,
	)

	if err == sql.ErrNoRows {
		return nil, ErrUserNotFound
	}

	return &u, err
}

// UpdatePassword updates a user's password
func (s *SQLStore) UpdatePassword(ctx context.Context, id, digest string) error {
	if s == nil || s.db == nil {
		return errors.New("database not configured")
	}

	query := `
		UPDATE users
		SET password_digest = $1, updated_at = $2
		WHERE id = $3
	`

	result, err := s.db.ExecContext(ctx, query, digest, time.Now(), id)
	if err != nil {
		return err
	}

	rows, err := result.RowsAffected()
	if err != nil {
		return err
	}

	if rows == 0 {
		return ErrUserNotFound
	}

	return nil
}

// ExistsEmail checks if email exists
func (s *SQLStore) ExistsEmail(ctx context.Context, email string) (bool, error) {
	if s == nil || s.db == nil {
		return false, errors.New("database not configured")
	}

	var count int
	query := `SELECT COUNT(*) FROM users WHERE email = $1`
	err := s.db.QueryRowContext(ctx, query, email).Scan(&count)
	return count > 0, err
}

// MemoryStore is an in-memory user store for testing/development
type MemoryStore struct {
	users   map[string]*User
	byEmail map[string]*User
}

// NewMemoryStore creates a new in-memory store
func NewMemoryStore() *MemoryStore {
	return &MemoryStore{
		users:   make(map[string]*User),
		byEmail: make(map[string]*User),
	}
}

// Create adds a user to memory
func (m *MemoryStore) Create(ctx context.Context, u *User) error {
	if _, exists := m.byEmail[u.Email]; exists {
		return ErrUserExists
	}

	u.ID = generateUUID()
	u.CreatedAt = time.Now()
	u.UpdatedAt = time.Now()

	m.users[u.ID] = u
	m.byEmail[u.Email] = u

	return nil
}

// ByEmail retrieves user by email from memory
func (m *MemoryStore) ByEmail(ctx context.Context, email string) (*User, error) {
	if u, ok := m.byEmail[email]; ok {
		return u, nil
	}
	return nil, ErrUserNotFound
}

// ByID retrieves user by ID from memory
func (m *MemoryStore) ByID(ctx context.Context, id string) (*User, error) {
	if u, ok := m.users[id]; ok {
		return u, nil
	}
	return nil, ErrUserNotFound
}

// UpdatePassword updates password in memory
func (m *MemoryStore) UpdatePassword(ctx context.Context, id, digest string) error {
	if u, ok := m.users[id]; ok {
		u.PasswordDigest = digest
		u.UpdatedAt = time.Now()
		return nil
	}
	return ErrUserNotFound
}

// ExistsEmail checks if email exists in memory
func (m *MemoryStore) ExistsEmail(ctx context.Context, email string) (bool, error) {
	_, exists := m.byEmail[email]
	return exists, nil
}

// Password helpers

// HashPassword creates a bcrypt hash from a plain password.
// Use this when creating users or changing passwords:
//
//	digest, err := auth.HashPassword("user's password")
//	user.PasswordDigest = digest
//
// bcrypt.DefaultCost (10) provides good security/performance balance.
// The hash includes a salt, so same password = different hashes.
func HashPassword(password string) (string, error) {
	bytes, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	return string(bytes), err
}

// CheckPassword compares a plain password with a bcrypt hash.
// Returns true if the password matches the hash.
//
// This is timing-safe - execution time doesn't reveal if user exists.
// Always returns false for empty password (prevents bypass attempts).
func CheckPassword(password, hash string) bool {
	err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
	return err == nil
}

// Helper to generate UUID (simplified version for demo).
// TODO: Use a proper UUID library like github.com/google/uuid
func generateUUID() string {
	return fmt.Sprintf("%d-%d", time.Now().UnixNano(), time.Now().Unix())
}

// Session management
// Sessions are the core of our authentication system. After successful login,
// we store the user's ID in an encrypted session cookie. On each request,
// we check this session to identify the user.

const sessionKey = "user_id" // Key used to store user ID in session map

// SetUserSession stores the user ID in the session after successful login.
// The session is encrypted with the AuthSecret before being sent as a cookie.
//
// Called by LoginHandler after verifying credentials:
//
//	SetUserSession(c, user.ID)
func SetUserSession(c buffalo.Context, userID string) error {
	session := c.Session()
	session.Set(sessionKey, userID)
	return session.Save() // Writes encrypted cookie to response
}

// GetUserSession retrieves the user ID from the session.
// Returns error if no user is logged in or session data is invalid.
//
// This is called by CurrentUser() and RequireLogin middleware to
// check if a user is authenticated.
func GetUserSession(c buffalo.Context) (string, error) {
	session := c.Session()
	userID := session.Get(sessionKey)

	if userID == nil {
		return "", errors.New("no user in session")
	}

	// Type assert to string (sessions store interface{})
	if id, ok := userID.(string); ok {
		return id, nil
	}

	return "", errors.New("invalid session data")
}

// ClearUserSession removes the user from the session (logout).
// This effectively logs the user out by removing their ID from the session.
//
// Called by LogoutHandler to end the user's session.
func ClearUserSession(c buffalo.Context) error {
	session := c.Session()
	session.Delete(sessionKey)
	return session.Save() // Updates the session cookie
}

// CurrentUser retrieves the current logged-in user from the session.
// This is a helper that combines GetUserSession with a database lookup.
//
// Returns nil and error if:
//   - No user is logged in (no session)
//   - User ID in session doesn't exist (deleted user)
//   - Database error occurs
//
// Usage in handlers:
//
//	user, err := auth.CurrentUser(c)
//	if err != nil {
//	    // User not logged in
//	}
func CurrentUser(c buffalo.Context) (*User, error) {
	userID, err := GetUserSession(c)
	if err != nil {
		return nil, err
	}

	return GetStore().ByID(c.Request().Context(), userID)
}

// RequireLogin is middleware that ensures user is authenticated.
// Add this to routes or groups that need protection:
//
//	app.GET("/admin", buffkit.RequireLogin(AdminHandler))
//	// or for a group:
//	protected := app.Group("/admin")
//	protected.Use(buffkit.RequireLogin)
//
// How it works:
//  1. Checks if user is logged in via session
//  2. If not, redirects to /login
//  3. If yes, adds user to context as "current_user" and continues
//
// Handlers can access the user via: c.Value("current_user").(*User)
func RequireLogin(next buffalo.Handler) buffalo.Handler {
	return func(c buffalo.Context) error {
		user, err := CurrentUser(c)
		if err != nil {
			// User not logged in - redirect to login page
			// Using 303 See Other for POST-to-GET redirect
			return c.Redirect(http.StatusSeeOther, "/login")
		}

		// Add user to context for handlers to access
		// This avoids repeated database lookups
		c.Set("current_user", user)

		return next(c)
	}
}

// LoginFormHandler renders the login form (GET /login).
// This shows the login page where users enter credentials.
//
// Features:
//   - Redirects to home if already logged in
//   - Shows any flash messages (errors from failed login)
//   - Includes CSRF token in form (added by Buffalo)
//
// In production, this would render a proper template from
// templates/auth/login.plush.html that can be shadowed by the app.
func LoginFormHandler(c buffalo.Context) error {
	// Check if already logged in - no need to show login form
	if user, _ := CurrentUser(c); user != nil {
		return c.Redirect(http.StatusSeeOther, "/")
	}

	// TODO: In production, render proper template with:
	// - CSRF token
	// - Flash messages for errors
	// - Remember me checkbox
	// - Forgot password link
	// - Sign up link

	// Stub HTML form for demonstration
	html := `
<!DOCTYPE html>
<html>
<head>
    <title>Login</title>
</head>
<body>
    <h1>Login</h1>
    <form method="POST" action="/login">
        <div>
            <label for="email">Email:</label>
            <input type="email" id="email" name="email" required>
        </div>
        <div>
            <label for="password">Password:</label>
            <input type="password" id="password" name="password" required>
        </div>
        <button type="submit">Login</button>
    </form>
</body>
</html>
	`

	return c.Render(http.StatusOK, authRenderer{html: html})
}

// LoginHandler processes login form submission (POST /login).
// This is where authentication actually happens:
//
//  1. Extract email/password from form
//  2. Look up user by email
//  3. Verify password against stored hash
//  4. Create session on success
//  5. Redirect to home (or return URL)
//
// Security notes:
//   - Same error message for "user not found" and "wrong password"
//   - Password comparison is timing-safe via bcrypt
//   - CSRF protection via Buffalo middleware
//   - Rate limiting should be added in production
func LoginHandler(c buffalo.Context) error {
	email := c.Param("email")
	password := c.Param("password")

	// Validate input
	if email == "" || password == "" {
		c.Flash().Add("error", "Email and password are required")
		return c.Redirect(http.StatusSeeOther, "/login")
	}

	// Find user by email
	user, err := GetStore().ByEmail(c.Request().Context(), email)
	if err != nil {
		// Don't reveal if user exists - same message for both cases
		c.Flash().Add("error", "Invalid email or password")
		return c.Redirect(http.StatusSeeOther, "/login")
	}

	// Check password - timing safe comparison via bcrypt
	if !CheckPassword(password, user.PasswordDigest) {
		c.Flash().Add("error", "Invalid email or password")
		return c.Redirect(http.StatusSeeOther, "/login")
	}

	// Authentication successful - create session
	if err := SetUserSession(c, user.ID); err != nil {
		return err
	}

	// TODO: Handle "return_to" parameter for post-login redirect
	// TODO: Trigger login event for audit logging
	// TODO: Update last_login_at timestamp

	c.Flash().Add("success", "Welcome back!")
	return c.Redirect(http.StatusSeeOther, "/")
}

// LogoutHandler clears the user session (POST /logout).
// This ends the user's session and redirects to login page.
//
// Why POST only: Logout should be POST to prevent CSRF attacks
// where a malicious site could log users out with an <img> tag.
//
// Usage: <form method="POST" action="/logout"><button>Logout</button></form>
func LogoutHandler(c buffalo.Context) error {
	// Clear the session - this removes the user_id
	if err := ClearUserSession(c); err != nil {
		return err
	}

	// TODO: Trigger logout event for audit logging
	// TODO: Invalidate remember-me token if implemented

	c.Flash().Add("success", "You have been logged out")
	return c.Redirect(http.StatusSeeOther, "/login")
}

// Simple HTML renderer for stub (Buffalo normally provides this)
type authRenderer struct {
	html string
}

func (authRenderer) HTML(s string) authRenderer {
	return authRenderer{html: s}
}

func (r authRenderer) ContentType() string {
	return "text/html; charset=utf-8"
}

func (r authRenderer) Render(w io.Writer, data render.Data) error {
	if hw, ok := w.(http.ResponseWriter); ok {
		hw.Header().Set("Content-Type", r.ContentType())
	}
	_, err := w.Write([]byte(r.html))
	return err
}
